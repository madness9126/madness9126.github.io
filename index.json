[{"categories":["C"],"content":"Socket网络编程详解(TCP) ","date":"2022-10-05","objectID":"/posts/thinking/socket%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B9%8Btcp/:1:0","tags":["C"],"title":"Socket网络编程之TCP","uri":"/posts/thinking/socket%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B9%8Btcp/"},{"categories":["C"],"content":"一、Socket的定义 套接字(Socket)，就是对网络中不同主机上的应用进程之间进行双向通信的端点的抽象。一个套接字就是网络上进程通信的一端，提供了应用层进程利用网络协议交换数据的机制。从所处的地位来讲，套接字上联应用进程，下联网络协议栈，是应用程序通过网络协议进行通信的接口，是应用程序与网络协议栈进行交互的接口 个人理解：socket其实就是一根通信电缆两端的电话终端，电话接通后就相当两个socket建立了连接，两个电话之间可以相互通话，两个socket之间就可以实时收发数据，socket仅仅是一个通信工具，通信工具，通信工具重要的事说三遍（OSI模型中的第四层传输层的API接口，这一层通常使用两种协议TCP或UDP来传输）并不是一种协议。TCP、UDP、HTTP才是我们通常理解的协议。 也就是说，Socket这个工具一般使用TCP和UDP两种协议来通信，否则光杆socket并没有毛用。其实我们所认识到的互联网中的各种通信：web请求、即时通讯、文件传输和共享等等底层都是通过Socket工具来实现的，所以说互联网一切皆socket。搞懂了socket你就相当于打通了任督二脉。 ","date":"2022-10-05","objectID":"/posts/thinking/socket%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B9%8Btcp/:1:1","tags":["C"],"title":"Socket网络编程之TCP","uri":"/posts/thinking/socket%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B9%8Btcp/"},{"categories":["C"],"content":"二、Socket的8个常用函数 Socket网络编程掌握下面几个C语言socket函数 1. int socket(int domain, int type, int protocol); socket函数对应于普通文件的打开操作。普通文件的打开操作返回一个文件描述字，而socket()用于创建一个socket描述符（socket descriptor），它唯一标识一个socket。这个socket描述字跟文件描述字一样，后续的操作都有用到它，把它作为参数，通过它来进行一些读写操作。 正如可以给fopen的传入不同参数值，以打开不同的文件。创建socket的时候，也可以指定不同的参数创建不同的socket描述符。 socket函数的三个参数和return分别为： domain：即协议域，又称为协议族（family）。通常我们只需关心这两个协议族就够了AF_INET、AF_INET6。AF_INET表示创建IPv4的socket，那么AF_INET6就表示创建IPv6的socket。 type：指定socket类型。常用的socket类型有，通常我们只需关心SOCK_STREAM、SOCK_DGRAM这两个类型也就够了，SOCK_STREAM表示TCP类型的socket，SOCK_DGRAM表示UDP类型的socket。 protocol：故名思意，就是指定协议。常用的协议有，IPPROTO_TCP、IPPTOTO_UDP、IPPROTO_SCTP、IPPROTO_TIPC等，它们分别对应TCP传输协议、UDP传输协议、STCP传输协议、TIPC传输协议。通常使用中只需记住这个参数设为0就够了。当protocol为0时，会自动选择type类型对应的默认协议。 return：套接口描述字。如果出现错误，它返回-1，并设置errno为相应的值 当我们调用socket创建一个socket时，返回的socket描述字它存在于协议族（address family，AF_XXX）空间中，但没有一个具体的地址。如果想要给它赋值一个地址，就必须调用bind()函数，否则就当调用connect()、listen()时系统会自动随机分配一个端口。具体下文详细说明。 2. int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen); 正如上面所说bind()函数把一个地址族中的特定地址（IP+Port）赋给socket。例如对应AF_INET、AF_INET6就是把一个ipv4或ipv6地址和端口号组合赋给socket。作为服务端我们必须给它指定一个端口号，要不然客户端就不知道该连哪个端口了。**所以服务器一般初始化问socket必须调用bind()函数绑定地址然后才能listen()。而客户端一般初始化完socket并且知道服务器IP地址和端口号就直接可以调用connect()函数进行连接了，**不需要绑定自己的地址，因为系统随机给客户端分配的地址（IP+Port）已经默默发送到服务器了。 三个参数及return的含义： sockfd：即socket描述字，它是通过socket()函数创建了，唯一标识一个socket。bind()函数就是将给这个描述字绑定一个名字。 addr：一个const struct sockaddr *指针，指向要绑定给sockfd的协议地址。这个地址结构根据地址创建socket时的地址协议族的不同而不同，如ipv4对应的是： struct sockaddr_in { sa_family_t sin_family; /* address family: AF_INET */ in_port_t sin_port; /* port in network byte order */ struct in_addr sin_addr; /* internet address */ }; addrlen：对应的是地址的长度。 return：成功返回0，失败返回-1 3. int listen(int sockfd, int backlog); 作为一个服务器，在调用socket()、bind()之后就会调用listen()来监听这个socket，如果客户端这时调用connect()发出连接请求，服务器端就会接收到这个请求。socket()函数创建的socket默认是一个主动类型的，listen函数将socket变为被动类型的，等待客户的连接请求。 sockfd：即为要监听的socket描述字 backlog：相应socket可以排队的最大连接个数。 return：成功返回0，失败返回-1 4. int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen); 作为客户端初始化完socket，不需要bind()就直接可以connect()与服务端建立连接了。因为系统会自动生成一个随机的地址（具体应该为本机IP+随机端口号）。 sockfd：还没绑定客户端具体地址的socket描述字 addr：即将要连接到服务端的地址（IP+port） addrlen：地址长度 return：如果是阻塞连接，成功立即返回0，如果失败，在iOS系统上超时大约一分钟后返回-1 5. int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen); TCP服务器端依次调用socket()、bind()、listen()之后，就会监听指定的socket地址了。TCP客户端依次调用socket()、connect()之后就向TCP服务器发送了一个连接请求。TCP服务器监听到这个请求之后，就会调用accept()函数取接收请求，并把会这样连接就建立好了。之后就可以开始网络I/O操作了，即类同于普通文件的读写I/O操作。 sockfd：已经绑定具体服务端地址的socket描述字。 sockaddr：一般为NULL,这个参数可以理解为interface指定连接必须从哪里来的，比如是localhost、wifi还是以太网卡。NULL为任意方式。 addrlen：sockaddr地址长度 return：成功返回服务器端socket描述字否则错误。 6. ssize_t write(int fd, const void *buf, size_t count); 服务端与客户端建立了通信接下来就可以实现网络通信了，可以调用网络I/O进行读写操作了，即实现了网络中不同进程之间的通信！ fd:要写入的的socket文件描述符 buf：将要被写入的缓冲区数据 count：被写入的数据长度 return：返回值大于0，表示写了部分数据或者是全部的数据，这样用一个while循环不断的写入数据，但是循环过程中的buf参数和count参数是我们自己来更新的，也就是说，网络编程中写函数是不负责将全部数据写完之后再返回的，说不定中途就返回了！返回值小于0表示出错。 7. ssize_t read(int fd, void *buf, size_t count); 如果系统事件源有了一个读取信号事件发生，那么我们可以调用read方法读取网络I/O中的数据。 fd：建立连接的socket文件描述符 buf：读取数据后放入的缓冲区 count：缓冲区大小 return：当读取成功时，read返回实际读取到的字节数，这样我们可以用一个while循环不断的读取数据，但是循环过程中的buf参数和count参数是我们自己来更新的，也就是说，网络编程中写函数是不负责将全部数据读取完之后再返回的。如果返回值是0，表示已经读取到文件的结束了，小于0表示是读取错误。 8. int close(int fd); 在服务器与客户端建立连接之后，会进行一些读写操作，完成了读写操作就要关闭相应的socket描述字，好比操作完打开的文件要调用fclose关闭打开的文件。 ","date":"2022-10-05","objectID":"/posts/thinking/socket%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B9%8Btcp/:1:2","tags":["C"],"title":"Socket网络编程之TCP","uri":"/posts/thinking/socket%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B9%8Btcp/"},{"categories":["Go"],"content":"package main import ( \"errors\" \"fmt\" \"os\" ) // 使用结构体管理队列 type Queue struct { Maxsize int array [5]int //数组 模拟队列 front int // 指向队列首部 rear int // 指向队列 尾部 } // 入队 func (q *Queue) Push(value int) (err error) { // 判断队列是否满 if q.rear == q.Maxsize-1 { return errors.New(\"queue full\") } q.rear++ q.array[q.rear] = value return } // 显示队列 func (q *Queue) showQueue() (err error) { if q.rear == q.front { return errors.New(\"queue has no element now\") } for i := q.front + 1; i \u003c= q.rear; i++ { fmt.Printf(\"%d\\t\", q.array[i]) } fmt.Println() return } // 出队 func (q *Queue) Pop() (value int, err error) { if q.front == q.rear { return value, errors.New(\"queue empty\") } q.front++ value = q.array[q.front] return } func main() { queue := \u0026Queue{ Maxsize: 5, front: -1, rear: -1, } var key string var value int for { fmt.Printf(\"-------------------------------\\n\") fmt.Printf(\"1、输入push 入队\\n2、输入pop 出队\\n3、输入show 显示队列\\n4、输入quit 表示退出\\n\") fmt.Scanln(\u0026key) switch key { case \"push\": fmt.Println(\"请输入你要入队的数据：\") fmt.Scanln(\u0026value) err := queue.Push(value) if err != nil { fmt.Println(err) } else { fmt.Println(\"入队成功\") } case \"pop\": value, err := queue.Pop() if err != nil { fmt.Println(err) } else { fmt.Println(\"出队数值\", value) } case \"show\": err := queue.showQueue() if err != nil { fmt.Println(err) } case \"quit\": os.Exit(0) } } } ","date":"2022-09-09","objectID":"/posts/thinking/golang%E9%98%9F%E5%88%97/:0:0","tags":["Go"],"title":"Golang队列","uri":"/posts/thinking/golang%E9%98%9F%E5%88%97/"},{"categories":["Hugo"],"content":"每次更新hugo博客所需的操作 ","date":"2022-09-07","objectID":"/posts/thinking/%E6%AF%8F%E6%AC%A1%E6%9B%B4%E6%96%B0hugo%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%93%8D%E4%BD%9C/:0:0","tags":["Hugo"],"title":"每次更新hugo博客的操作","uri":"/posts/thinking/%E6%AF%8F%E6%AC%A1%E6%9B%B4%E6%96%B0hugo%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%93%8D%E4%BD%9C/"},{"categories":["Hugo"],"content":"打开 Powercmd / cmd 终端，打开最初用 hugo 搭建的博客所在的文件夹，以我为例： cd D:\\Blog 第一步： ","date":"2022-09-07","objectID":"/posts/thinking/%E6%AF%8F%E6%AC%A1%E6%9B%B4%E6%96%B0hugo%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%93%8D%E4%BD%9C/:0:1","tags":["Hugo"],"title":"每次更新hugo博客的操作","uri":"/posts/thinking/%E6%AF%8F%E6%AC%A1%E6%9B%B4%E6%96%B0hugo%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%93%8D%E4%BD%9C/"},{"categories":["Hugo"],"content":"新建一个 markdown(.md) 格式的文件： hugo new post/FileName.md ","date":"2022-09-07","objectID":"/posts/thinking/%E6%AF%8F%E6%AC%A1%E6%9B%B4%E6%96%B0hugo%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%93%8D%E4%BD%9C/:0:2","tags":["Hugo"],"title":"每次更新hugo博客的操作","uri":"/posts/thinking/%E6%AF%8F%E6%AC%A1%E6%9B%B4%E6%96%B0hugo%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%93%8D%E4%BD%9C/"},{"categories":["Hugo"],"content":"其中 FileName 为自定义的文件名 第二步： ","date":"2022-09-07","objectID":"/posts/thinking/%E6%AF%8F%E6%AC%A1%E6%9B%B4%E6%96%B0hugo%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%93%8D%E4%BD%9C/:1:0","tags":["Hugo"],"title":"每次更新hugo博客的操作","uri":"/posts/thinking/%E6%AF%8F%E6%AC%A1%E6%9B%B4%E6%96%B0hugo%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%93%8D%E4%BD%9C/"},{"categories":["Hugo"],"content":"输入命令： hugo 第三步： ","date":"2022-09-07","objectID":"/posts/thinking/%E6%AF%8F%E6%AC%A1%E6%9B%B4%E6%96%B0hugo%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%93%8D%E4%BD%9C/:1:1","tags":["Hugo"],"title":"每次更新hugo博客的操作","uri":"/posts/thinking/%E6%AF%8F%E6%AC%A1%E6%9B%B4%E6%96%B0hugo%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%93%8D%E4%BD%9C/"},{"categories":["Hugo"],"content":"把博客部署到远程GitHub仓库 ","date":"2022-09-07","objectID":"/posts/thinking/%E6%AF%8F%E6%AC%A1%E6%9B%B4%E6%96%B0hugo%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%93%8D%E4%BD%9C/:1:2","tags":["Hugo"],"title":"每次更新hugo博客的操作","uri":"/posts/thinking/%E6%AF%8F%E6%AC%A1%E6%9B%B4%E6%96%B0hugo%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%93%8D%E4%BD%9C/"},{"categories":["Hugo"],"content":"1. 首先切换到 public 文件夹： cd public ","date":"2022-09-07","objectID":"/posts/thinking/%E6%AF%8F%E6%AC%A1%E6%9B%B4%E6%96%B0hugo%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%93%8D%E4%BD%9C/:1:3","tags":["Hugo"],"title":"每次更新hugo博客的操作","uri":"/posts/thinking/%E6%AF%8F%E6%AC%A1%E6%9B%B4%E6%96%B0hugo%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%93%8D%E4%BD%9C/"},{"categories":["Hugo"],"content":"此时，正处于 D:\\Blog\\public 中 ","date":"2022-09-07","objectID":"/posts/thinking/%E6%AF%8F%E6%AC%A1%E6%9B%B4%E6%96%B0hugo%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%93%8D%E4%BD%9C/:1:4","tags":["Hugo"],"title":"每次更新hugo博客的操作","uri":"/posts/thinking/%E6%AF%8F%E6%AC%A1%E6%9B%B4%E6%96%B0hugo%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%93%8D%E4%BD%9C/"},{"categories":["Hugo"],"content":"2. 接下来输入以下指令： git add . git commit -m \"yyyy/mm/dd-hh:mm\" git push -u origin master ","date":"2022-09-07","objectID":"/posts/thinking/%E6%AF%8F%E6%AC%A1%E6%9B%B4%E6%96%B0hugo%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%93%8D%E4%BD%9C/:1:5","tags":["Hugo"],"title":"每次更新hugo博客的操作","uri":"/posts/thinking/%E6%AF%8F%E6%AC%A1%E6%9B%B4%E6%96%B0hugo%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%93%8D%E4%BD%9C/"},{"categories":["Hugo"],"content":"其中 yyyy/mm/dd-hh:mm 为每次提交的备注，引号内可以随意更改，yyyy/mm/dd-hh:mm 是以时间做标记可保证不会重复 ","date":"2022-09-07","objectID":"/posts/thinking/%E6%AF%8F%E6%AC%A1%E6%9B%B4%E6%96%B0hugo%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%93%8D%E4%BD%9C/:1:6","tags":["Hugo"],"title":"每次更新hugo博客的操作","uri":"/posts/thinking/%E6%AF%8F%E6%AC%A1%E6%9B%B4%E6%96%B0hugo%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%93%8D%E4%BD%9C/"},{"categories":["Hugo"],"content":"3. 现在刷新GitHub，登陆个人博客查看即可 ","date":"2022-09-07","objectID":"/posts/thinking/%E6%AF%8F%E6%AC%A1%E6%9B%B4%E6%96%B0hugo%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%93%8D%E4%BD%9C/:1:7","tags":["Hugo"],"title":"每次更新hugo博客的操作","uri":"/posts/thinking/%E6%AF%8F%E6%AC%A1%E6%9B%B4%E6%96%B0hugo%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%93%8D%E4%BD%9C/"},{"categories":["Go"],"content":"package main import ( \"fmt\" ) type Node struct { data int next *Node } func SingleCreate(data int) *Node { return \u0026Node{ data: data, next: nil, } } //创建单个节点 func CreateList(lenth int) *Node { var head *Node = new(Node) head.data = 0 temp := head for i := 1; i \u003c lenth; i++ { node := new(Node) node.data = i temp.next = node temp = node } return head } //创建链表 func err(node *Node) { if node == nil { return } } func LenthList(head Node) int { err(\u0026head) temp := \u0026head i := 1 for { temp = temp.next i++ if temp.next == nil { break } } return i } //计算链表长度 func PrintList(head Node) { err(\u0026head) temp := \u0026head for { fmt.Printf(\"%d \", temp.data) temp = temp.next if temp.next == nil { fmt.Printf(\"%d \", temp.data) break } } fmt.Printf(\"\\n\") } //打印链表 func AddNode(head *Node, data int, location int) *Node { if location \u003c= 0 || location \u003e LenthList(*head) { fmt.Printf(\"out of the lenth(no change)\\n\") return head } var nnode *Node = new(Node) nnode.data = data if location == 1 { nnode.next = head return nnode } temp := head for i := 1; i \u003c location-1; i++ { temp = temp.next } nnode.next = temp.next temp.next = nnode return head } func DeleteNodeByPosition(head *Node, Position int) *Node { temp := head if Position \u003c 0 || Position \u003e LenthList(*head) { fmt.Printf(\"out of the lenth(no change)\\n\") return head } if Position == 1 { return head.next } for i := 1; i \u003c Position-1; i++ { temp = temp.next } if Position == LenthList(*head) { temp.next = nil return head } temp.next = temp.next.next return head } func DeleteNodeByValue(head *Node, Value int) *Node { temp := head temp1 := head var i, j int i = 1 for { if temp.data == Value { break } else { temp = temp.next } i++ if temp.next == nil { break } } if temp.data != Value { fmt.Printf(\"not found this value\\n\") return head } if i == 1 { return head.next } for j = 1; j \u003c i-1; j++ { temp1 = temp1.next } temp1.next = temp1.next.next return head } func SearchByPosition(head *Node, Position int) int { temp := head if Position \u003c 0 || Position \u003e LenthList(*head) { fmt.Printf(\"error,out of the lenth !\\n\") return -1 } if Position == 1 { fmt.Printf(\"No.%d value is %d\", Position, head.data) return head.data } for i := 0; i \u003c Position-1; i++ { temp = temp.next } fmt.Printf(\"No.%d value is %d\", Position, temp.data) return temp.data } func Modify(head *Node, Position int, Value int) { temp := head if Position \u003c 0 || Position \u003e LenthList(*head) { fmt.Printf(\"error,out of the lenth !\\n\") return } for i := 0; i \u003c Position-1; i++ { temp = temp.next } temp.data = Value } func ReverseList(head *Node) *Node { err(head) newhead := head node := head.next for node != nil { newhead.next = node.next node.next = head head = node node = newhead.next } return head } func CheckCircle(head Node) int { slow := \u0026head fast := \u0026head for fast.next != nil \u0026\u0026 fast != nil { slow = slow.next fast = fast.next.next if slow == fast { fmt.Printf(\"Has Cycle,value is %d\\n\", slow.data) slow = \u0026head i := 0 for slow != fast { slow = slow.next i++ } return i } } return -1 } func main() { //创建链表 返回表头head var head = CreateList(10) fmt.Printf(\"Head List\\n\") PrintList(*head) fmt.Println(\"Lenth of List is \", LenthList(*head)) fmt.Println(\"-------------------\") //添加元素 返回表头head1 fmt.Printf(\"Head1 List\\n\") head1 := AddNode(head, 11, 7) PrintList(*head1) //删除head1元素 返回表头head2 fmt.Println(\"-------------------\") fmt.Printf(\"Head2 List After Position Delete\\n\") head2 := DeleteNodeByPosition(head1, 11) PrintList(*head2) //删除head2元素 返回表头head3 fmt.Println(\"-------------------\") fmt.Printf(\"Head3 List After Value Delete\\n\") head3 := DeleteNodeByValue(head2, 11) PrintList(*head3) //查询head3元素 fmt.Println(\"-------------------\") SearchByPosition(head3, 9) //修改head3某个位置的值 fmt.Println(\"\\n-------------------\") Modify(head3, 9, 10) PrintList(*head3) SearchByPosition(head3, 9) //反转链表，返回表头head4 fmt.Println(\"\\n-------------------\") head4 := ReverseList(head3) fmt.Printf(\"After Reverse\\n\") PrintList(*head4) //检测有无环 fmt.Println(\"-------------------\") temp := head4 for i := 1; i \u003c","date":"2022-09-06","objectID":"/posts/thinking/golang%E9%93%BE%E8%A1%A8/:0:0","tags":["Go"],"title":"Golang链表","uri":"/posts/thinking/golang%E9%93%BE%E8%A1%A8/"},{"categories":["MarkDown"],"content":"1. 分级标题 一级 用 # ","date":"2022-08-09","objectID":"/posts/thinking/markdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/:0:0","tags":["MarkDown语法"],"title":"MarkDown常用语法","uri":"/posts/thinking/markdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/"},{"categories":["MarkDown"],"content":"二级 用 ## … …(以此类推) 2. 段落 创建段落，请使用空白行将一行或多行文本进行分隔。 不要用空格（spaces）或制表符（tabs）缩进段落。 Don’t put tabs or spaces in front of your paragraphs. Keep lines left-aligned like this. 3. 换行 在一行的末尾添加两个或多个空格，然后按回车键,即可创建一个换行 或者在一行的末尾添加HTML\u003cbr\u003e 标签来实现换行 First line with two spaces after.\u003cbr\u003e\u003cbr\u003e And the next line. First line with the HTML tag after.\u003cbr\u003e And the next line. 4. 强调 ","date":"2022-08-09","objectID":"/posts/thinking/markdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/:1:0","tags":["MarkDown语法"],"title":"MarkDown常用语法","uri":"/posts/thinking/markdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/"},{"categories":["MarkDown"],"content":"加粗： 在需要加粗的单词或短语各添加两个星号**或两个下划线__。 ","date":"2022-08-09","objectID":"/posts/thinking/markdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/:2:0","tags":["MarkDown语法"],"title":"MarkDown常用语法","uri":"/posts/thinking/markdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/"},{"categories":["MarkDown"],"content":"斜体： 在单词或短语前后添加一个星号*或下划线_ 要斜体突出单词中间部分，在字母前后各添加一个*，中间不要空格。不能用下划线_ ","date":"2022-08-09","objectID":"/posts/thinking/markdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/:3:0","tags":["MarkDown语法"],"title":"MarkDown常用语法","uri":"/posts/thinking/markdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/"},{"categories":["MarkDown"],"content":"斜体加粗： 在单词或短语的前后各添加三个星号*或三个下划线。 加粗并用斜体显示中间部分，在要突出显示的部分前后各添加三个星号***，中间无空格。不能用三个下划线_ 5. 引用 创建块引用，请在段落前添加一个\u003e符号。 块引用可以包含多个段落。为段落之间的空白行添加一个\u003e符号。 块引用可以嵌套。在要嵌套的段落前添加一个\u003e\u003e符号。 6. 列表 ","date":"2022-08-09","objectID":"/posts/thinking/markdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/:4:0","tags":["MarkDown语法"],"title":"MarkDown常用语法","uri":"/posts/thinking/markdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/"},{"categories":["MarkDown"],"content":"有序列表： 要创建有序列表，请在每个列表项前添加数字并紧跟一个英文句点.。 ","date":"2022-08-09","objectID":"/posts/thinking/markdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/:5:0","tags":["MarkDown语法"],"title":"MarkDown常用语法","uri":"/posts/thinking/markdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/"},{"categories":["MarkDown"],"content":"无序列表： 要创建无序列表，请在每个列表项前面添加破折号-、星号* 或加号+ 7. 代码 ","date":"2022-08-09","objectID":"/posts/thinking/markdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/:6:0","tags":["MarkDown语法"],"title":"MarkDown常用语法","uri":"/posts/thinking/markdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/"},{"categories":["MarkDown"],"content":"表示为代码： 要将单词或短语表示为代码，请将其包裹在反引号 ` 中。 ","date":"2022-08-09","objectID":"/posts/thinking/markdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/:7:0","tags":["MarkDown语法"],"title":"MarkDown常用语法","uri":"/posts/thinking/markdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/"},{"categories":["MarkDown"],"content":"转义反引号： 如果你要表示为代码的单词或短语中包含一个或多个反引号，则可以通过将单词或短语包裹在双反引号``中。 ","date":"2022-08-09","objectID":"/posts/thinking/markdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/:8:0","tags":["MarkDown语法"],"title":"MarkDown常用语法","uri":"/posts/thinking/markdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/"},{"categories":["MarkDown"],"content":"表示代码块： 要表示一大段代码可以在代码块前后各用三个反引号```。 8. 分隔线 要创建分隔线，请在单独一行上使用三个或多个星号 ***、破折号 --- 或下划线 ___ ，并且不能包含其他内容。 9. 链接 链接文本放在中括号内，链接地址放在后面的括号中，链接title可选。 超链接Markdown语法代码：[超链接显示名](超链接地址 \"超链接title\") アニャ…これわlinkです！ ","date":"2022-08-09","objectID":"/posts/thinking/markdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/:9:0","tags":["MarkDown语法"],"title":"MarkDown常用语法","uri":"/posts/thinking/markdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/"},{"categories":["MarkDown"],"content":"给链接加Title： 链接title是当鼠标悬停在链接上时会出现的文字，这个title是可选的，它放在圆括号中链接地址后面，跟链接地址之间以空格分隔。 ","date":"2022-08-09","objectID":"/posts/thinking/markdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/:10:0","tags":["MarkDown语法"],"title":"MarkDown常用语法","uri":"/posts/thinking/markdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/"},{"categories":["MarkDown"],"content":"网址和Email地址： 使用尖括号\u003c\u003e可以很方便地把URL或者email地址变成可点击的链接。 10. 图片插入 要添加图像，请使用感叹号 !, 然后在方括号增加替代文本，图片链接放在圆括号里，括号里的链接后可以增加一个可选的图片标题文本。 ","date":"2022-08-09","objectID":"/posts/thinking/markdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/:11:0","tags":["MarkDown语法"],"title":"MarkDown常用语法","uri":"/posts/thinking/markdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/"},{"categories":["MarkDown"],"content":"插入图片Markdown语法代码： ![图片alt](图片链接 \"图片title\") ","date":"2022-08-09","objectID":"/posts/thinking/markdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/:12:0","tags":["MarkDown语法"],"title":"MarkDown常用语法","uri":"/posts/thinking/markdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/"},{"categories":["MarkDown"],"content":"链接图片： 给图片增加链接，请将图像的Markdown语句括在方括号[]中，然后将链接添加在圆括号()中。 ","date":"2022-08-09","objectID":"/posts/thinking/markdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/:13:0","tags":["MarkDown语法"],"title":"MarkDown常用语法","uri":"/posts/thinking/markdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/"},{"categories":["C"],"content":"C语言的文件管理部分内容 ","date":"2022-07-24","objectID":"/posts/thinking/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/:0:0","tags":["C"],"title":"文件管理","uri":"/posts/thinking/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/"},{"categories":["C"],"content":"1. 从文件中逐个输入字符及向文件中逐个输出字符的顺序读写函数 fgetc 和 fputc 调整文件读写位置到文件开始处的函数 rewind 头文件：#include \u003cstdio.h\u003e ","date":"2022-07-24","objectID":"/posts/thinking/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/:1:0","tags":["C"],"title":"文件管理","uri":"/posts/thinking/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/"},{"categories":["C"],"content":"字符输入函数 fgetc 的函数原型为: int fgetc (FILE *fp); EOF=-1 由于 fgetc 是以 unsigned char 的形式从文件 中输入（读取）一个字节，并在该字节前面补充若干 0 字节，使之扩展为该系统中的一个 int 型数并返回，而非直接返回 char 型。当输入失败时返回文本文件结束标志 EOF 即 -1，也是整数。故返回类型应为 int 型，而非 char 型。 ","date":"2022-07-24","objectID":"/posts/thinking/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/:1:1","tags":["C"],"title":"文件管理","uri":"/posts/thinking/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/"},{"categories":["C"],"content":"字符输出函数 fputc 的函数原型为： int fputc (int c, FILE *fp); ","date":"2022-07-24","objectID":"/posts/thinking/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/:1:2","tags":["C"],"title":"文件管理","uri":"/posts/thinking/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/"},{"categories":["C"],"content":"2. 常见的字符串输入、输出函数 fgets 和 fputs。 ","date":"2022-07-24","objectID":"/posts/thinking/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/:2:0","tags":["C"],"title":"文件管理","uri":"/posts/thinking/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/"},{"categories":["C"],"content":"字符串输入 char * fgets (char *s, int size, FILE * fp); fgets：函数功能：从 fp 所指向的文件内，读取若干字符（一行字符串），并在其后自动添加字符串结束标志 ‘\\0’ 后，存入 s 所指的缓冲内存空间中（s 可为字符数组名），直到遇到回车换行符或已读取 size-1 个字符或已读到文件结尾为止。该函数读取的字符串最大长度为 size-1。 参数 fp:可以指向磁盘文件或标准输入设备 stdin。 返回值：读取成功，返回缓冲区地址 s；读取失败，返回 NULL。 ","date":"2022-07-24","objectID":"/posts/thinking/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/:2:1","tags":["C"],"title":"文件管理","uri":"/posts/thinking/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/"},{"categories":["C"],"content":"字符串输出 int fputs (const char *str, FILE *fp); fputs：函数功能：把 str（str 可为字符数组名）所指向的字符串，输出到 fp 所指的文件中。 返回值：输出成功，返回非负数；输出失败，返回EOF(-1)。 ","date":"2022-07-24","objectID":"/posts/thinking/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/:2:2","tags":["C"],"title":"文件管理","uri":"/posts/thinking/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/"},{"categories":["C"],"content":"3. 文件操作中的格式化输入输出函数 fscanf 和 fprintf ","date":"2022-07-24","objectID":"/posts/thinking/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/:3:0","tags":["C"],"title":"文件管理","uri":"/posts/thinking/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/"},{"categories":["C"],"content":"格式化输入 文件格式化输入函数 fscanf 的函数原型为： int fscanf (文件指针，格式控制串，输入地址表列); 函数功能：从一个文件流中执行格式化输入，当遇到空格或者换行时结束。注意该函数遇到空格时也结束，这是其与 fgets 的区别，fgets 遇到空格不结束。 返回值：返回整型，输入成功时，返回输入的数据个数；输入失败，或已读取到文件结尾处，返回 EOF(-1)。 故一般可根据该函数的返回值是否为 EOF 来判断是否已读到文件结尾处。 ","date":"2022-07-24","objectID":"/posts/thinking/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/:3:1","tags":["C"],"title":"文件管理","uri":"/posts/thinking/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/"},{"categories":["C"],"content":"格式化输出 文件格式化输出函数fprintf的函数原型为： int fprintf (文件指针，格式控制串，输出表列)； 函数功能：把输出表列中的数据按照指定的格式输出到文件中。 返回值：输出成功，返回输出的字符数；输出失败，返回一负数。 ","date":"2022-07-24","objectID":"/posts/thinking/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/:3:2","tags":["C"],"title":"文件管理","uri":"/posts/thinking/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/"},{"categories":["C"],"content":"Avl树 AVL树本质上还是一棵二叉搜索树，它的特点是： 本身首先是一棵二叉搜索树。 带有平衡条件：每个结点的左右子树的高度之差的绝对值（平衡因子）最多为1。 也就是说，AVL树，本质上是带了平衡功能的二叉查找树（二叉排序树，二叉搜索树）。 #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e typedef struct avl { struct avl *left; struct avl *right; int key; int high; } avl, *avlp; int max(int a, int b) { return a \u003e b ? a : b; } void avllist(avlp root) { if (root) { printf(\"key:%d high:%d\\n\", root-\u003ekey, root-\u003ehigh); avllist(root-\u003eleft); avllist(root-\u003eright); } } int avlhigh(avlp tree) { if (!tree) { return -1; } else return max(avlhigh(tree-\u003eleft), avlhigh(tree-\u003eright)) + 1; } // ll avlp right_rotation(avlp tree) { avlp node = tree-\u003eleft; tree-\u003eleft = node-\u003eright; //保存废弃节点 node-\u003eright = tree; //连接 //计算树高 tree-\u003ehigh = avlhigh(tree); node-\u003ehigh = avlhigh(node); return node; } // RR avlp left_rotation(avlp tree) { avlp node = tree-\u003eright; tree-\u003eright = node-\u003eleft; node-\u003eleft = tree; tree-\u003ehigh = avlhigh(tree); node-\u003ehigh = avlhigh(node); return node; } // lR avlp left_right_rotation(avlp tree) { tree-\u003eleft = left_rotation(tree-\u003eleft); return right_rotation(tree); } // Rl avlp right_left_rotation(avlp tree) { tree-\u003eright = right_rotation(tree-\u003eright); return left_rotation(tree); } avlp rebalance(avlp tree, int key) { int factor = avlhigh(tree-\u003eleft) - avlhigh(tree-\u003eright); if (factor \u003e 1) { if (key \u003e tree-\u003eleft-\u003ekey) { printf(\"left_right_rotation \\n\"); tree = left_right_rotation(tree); } else { printf(\"right_rotation \\n\"); tree = right_rotation(tree); } } if (factor \u003c -1) { if (key \u003e tree-\u003eright-\u003ekey) { printf(\"left_rotation \\n\"); tree = left_rotation(tree); } else { printf(\"right_left_rotation \\n\"); tree = right_left_rotation(tree); } } return tree; } avlp avlinsert(avlp tree, int value) { if (!tree) { avlp node = (avlp)malloc(sizeof(avl)); if (!node) { printf(\"node is malloc error\"); return NULL; } node-\u003ekey = value; node-\u003ehigh = 0; node-\u003eleft = NULL; node-\u003eright = NULL; return node; } if (value \u003e= tree-\u003ekey) { tree-\u003eright = avlinsert(tree-\u003eright, value); //从rigth递去,tree-\u003e表示连接 tree-\u003ehigh = avlhigh(tree); } else { tree-\u003eleft = avlinsert(tree-\u003eleft, value); //从left递去 tree-\u003ehigh = avlhigh(tree); } tree = rebalance(tree, value); return tree; } avlp findmin(avlp tree) { if (!tree) { return NULL; } if (!tree-\u003eleft) { return tree; } else return findmin(tree-\u003eleft); } avlp findmax(avlp tree) { if (!tree) { return NULL; } if (!tree-\u003eright) { return tree; } else return findmax(tree-\u003eright); } avlp avldelete(avlp tree, int key) { if (!tree) { return NULL; } if (key \u003e tree-\u003ekey) { tree-\u003eright = avldelete(tree-\u003eright, key); tree = rebalance(tree,key); } if (key \u003c tree-\u003ekey) { tree-\u003eleft = avldelete(tree-\u003eleft, key); tree = rebalance(tree,key); } if (key == tree-\u003ekey) { if (tree-\u003eleft \u0026\u0026 tree-\u003eright) { if (avlhigh(tree-\u003eleft) \u003e avlhigh(tree-\u003eright)) { avlp max = findmax(tree-\u003eleft); //找出左子树最大值 tree-\u003ekey = max-\u003ekey; // swap tree-\u003eleft = avldelete(tree-\u003eleft, max-\u003ekey); } else { avlp min = findmin(tree-\u003eright); tree-\u003ekey = min-\u003ekey; tree-\u003eright = avldelete(tree-\u003eright, min-\u003ekey); } } else{ avlp node = NULL; node = tree; if (!tree-\u003eleft) { tree = tree-\u003eright; } else if(!tree-\u003eright) tree = tree-\u003eleft; else tree = NULL; } } return tree; } int main() { avlp tree = NULL; tree = avlinsert(tree,8); tree = avlinsert(tree,3); tree = avlinsert(tree,9); tree = avlinsert(tree,10); tree = avlinsert(tree,12); tree = avlinsert(tree,14); tree = avlinsert(tree,6); tree = avlinsert(tree,5); tree = avlinsert(tree,1); printf(\"***前序***: \\n\"); avllist(tree); tree = avldelete(tree,10); printf(\"***前序***: \\n\"); avllist(tree); } ","date":"2022-03-21","objectID":"/posts/coding/avl%E6%A0%91/:0:1","tags":["C"],"title":"Avl树","uri":"/posts/coding/avl%E6%A0%91/"},{"categories":["C"],"content":"#include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e //字符串匹配搜索算法BF、RK、BM、KMP /* * BF算法，暴力匹配算法（） * Rk算法，利用哈希函数将字符串转换成数字，比较哈希值，26进制计算或者按位计算，前者避免了哈希 冲突，后者可能会出现abc=bca这种情况 * bm算法，好后缀，坏字符规则 * kmp算法 */ int LengthString(char *s) //求字符串长度 { int i = 0; while (*s != '\\0') //解引用，字符串最后一位是'\\0' { i++; s++; } return i; } // BF算法，暴力匹配算法（） char *Bfstring(char *x, char *y) // x is master string,y is module string { char *temp = x; char *swap = y; while (*x != '\\0') { while (*temp == *swap) { *temp++; *swap++; if (*temp == '\\0') { return NULL; } if (*swap == '\\0') { return x; } } x++; //主串移1位，x，y复位 temp = x; swap = y; } return NULL; } // Rk算法，利用哈希函数将字符串转换成数字，比较哈希值，26进制计算或者按位计算，前者避免了哈希冲突，后者可能会出现abc=bca这种情况 char *RkString(char *x, char *y) // 10进制 { int len = LengthString(y); int sum_x = 0, sum_y = 0; char *x_tail = x, *y_tail = y; while (*y_tail != '\\0') { sum_x = sum_x + *x_tail; sum_y = sum_y + *y_tail; x_tail++; y_tail++; } //计算模式串和主串的哈希值，sum_x为主串某段的哈希值，sum_y为模式串的哈希值 x_tail--; y_tail--; while (*x_tail != '\\0') { int n_len = len; char *temp_x = x; char *temp_y = y; while (sum_x == sum_y) { if (*temp_x != *temp_y) { break; } if (n_len == 1) { return x; } temp_x++; temp_y++; n_len--; } x++; x_tail++; sum_x = sum_x - *x + *x_tail; // printf(\"%d %d\\n\", sum_x, sum_y); } return NULL; } // bm算法，好后缀，坏字符规则 char *Bmstring(char *x, char *y) //坏字符规则 { int len = LengthString(y); int n_len = len; char *temp_x = x; char *temp_y = y; char *temp_head_y = y; while (*temp_y != '\\0') { temp_x++; temp_y++; } temp_x--; temp_y--; x = temp_x; y = temp_y; while (*temp_x != '\\0') { n_len = len; while (*temp_y != *x \u0026\u0026 n_len \u003e= 1) { temp_x++; temp_y--; n_len--; } x = temp_x; temp_y = y; n_len = len; while (*temp_y == *temp_x) { temp_x--; temp_y--; n_len--; if (n_len == 1) { return temp_x; } } } return NULL; } // kmp算法实现 char *KmpString(char *x, char *y) { //构造PMT数组 int x_len = LengthString(x); int len = LengthString(y); int *pmt = (int *)malloc(sizeof(int)*len);//动态申请数组，注意这里要求int型 if (pmt == NULL)//开辟内存失败，返回null { return NULL;//可以换成eixt(-1);退出程序 } pmt[0] = 0;//规定首位为0， int j = 0,i = 1;//初始化定义，0，1为自选数值，这里刚刚好这样初始化方便一些 while (i \u003c= len-1) { //不等判断，且此时模式串不能是第一位，如果是第一位则跳出循环 while (y[i] != y[j] \u0026\u0026 j \u003e 0)//j代表此时模式串的位置，也是可以迭代回归的次数 { j = pmt[j-1];//kmp算法核心，跳转回相同公共词缀的位置 //printf(\"%c \\n\",y[j]); } //等值判断，移动j的位置 if (y[j] == y[i]) { j++; } pmt[i] = j;//将此时的公共词缀赋予数组 i++;// } // for (int i = 0; i \u003c len; i++) // { // printf(\"%d \\n\",pmt[i]); // } //kmp算法部分，和上面的部分类似，但是不同的是要找到成功配对的出口和配对不成功的出口 j = 0; i = 0; while (i\u003cx_len)//循环条件 { while (x[i] != y[j] \u0026\u0026 j \u003e 0) { j = pmt[j-1];//使用配对信息表 } if (x[i] == y[j]) { j++; } if (j == len)//成功条件 { return \u0026x[i-len+1];//这里返回的是主串中的位置 } i++;//自加1 } return NULL;//失败条件 } //主函数 int main() { char *Q = \"GTGTGAGCTGGTGTGTGCFAA\"; char *p = \"GTGTGCF\"; char *p1 = \"GTGTGCFG\"; char *bf = Bfstring(Q, p); //时间复杂度为m*n printf(\"%s:%s\\n\", \"bf\", bf); char *Rk = RkString(Q, p); // 本来可以是m,但是处理了冲突部分，耗时过多 printf(\"%s:%s\\n\", \"RK\", Rk); char *Bm = Bmstring(Q, p); //时间复杂度依据实际情况而定，最坏m*n printf(\"%s:%s\\n\", \"bm\", Bm); char *kmp = KmpString(Q,p);//m+n printf(\"%s %s\\n\",\"kmp:\",kmp); return 0; } ","date":"2022-03-17","objectID":"/posts/coding/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95/:0:0","tags":["C"],"title":"字符串匹配算法","uri":"/posts/coding/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95/"},{"categories":["C"],"content":"binary tree 二叉树 #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e //树节点 struct node { int data; struct node *left; struct node *right; }; struct node *newnode(int data) { struct node *node = (struct node *)malloc(sizeof(struct node)); node-\u003edata = data; node-\u003eleft = NULL; node-\u003eright = NULL; return (node); } //树的遍历 //前序、中序、后序 void printPostorder(struct node *node)//后序 { if(node == NULL) return; //递归遍历 printPostorder(node-\u003eleft); printPostorder(node-\u003eright); printf(\"%d \",node-\u003edata); } void printInorder(struct node *node)//中序 { if(node == NULL) return; printInorder(node-\u003eleft); printf(\"%d \",node-\u003edata); printInorder(node-\u003eright); } void printPreorder(struct node *node)//前序 { if(node == NULL) return; printf(\"%d \",node-\u003edata); printPreorder(node-\u003eleft); printPreorder(node-\u003eright); } int main() { struct node *root = newnode(1); root-\u003eleft = newnode(2); root-\u003eright = newnode(3); root-\u003eleft-\u003eleft = newnode(4); root-\u003eleft-\u003eright = newnode(5);//创建树 printf(\"\\npreorder\\n\"); printPreorder(root); printf(\"\\ninorder\\n\"); printInorder(root); printf(\"\\npostorder\\n\"); printPostorder(root); return 0; } ","date":"2022-03-15","objectID":"/posts/coding/%E4%BA%8C%E5%8F%89%E6%A0%91/:0:0","tags":["C"],"title":"二叉树","uri":"/posts/coding/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"categories":["C"],"content":"#include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #define bool int //树节点 struct tNode { int data; struct tNode *left; struct tNode *right; }; //堆栈 struct sNode { struct tNode *t; struct sNode *next; }; //堆栈相关函数 void push(struct sNode **top_ref , struct tNode *t); struct tNode *pop(struct sNode **top_ref); bool isEmpty(struct sNode *top); //迭代遍历顺序树函数 void inOrder(struct tNode *root) { struct tNode *current = root; struct sNode *s = NULL; bool done = 0; while(!done) { if(current != NULL) { push(\u0026s,current); current = current-\u003eleft; } else { if(!isEmpty(s)) { current = pop(\u0026s); printf(\"%d \",current-\u003edata); current = current-\u003eright; } else done = 1; } }// end of while } void push(struct sNode **top_ref , struct tNode *t) { struct sNode *new_tNode = (struct sNode*)malloc(sizeof(struct sNode)); if(new_tNode == NULL) { printf(\"stack overflow\\n\"); getchar(); exit(0); } new_tNode-\u003et = t; new_tNode-\u003enext = (*top_ref); (*top_ref) = new_tNode; } bool isEmpty(struct sNode *top) { return (top == NULL)?1:0; } struct tNode *pop(struct sNode **top_ref) { struct tNode *res; struct sNode *top; if(isEmpty(*top_ref)) { printf(\"Stack underflow\\n\"); getchar(); exit(0); } else { top = *top_ref; res = top-\u003et; *top_ref = top-\u003enext; free(top); return res; } } struct tNode *newNode(int data) { struct tNode *tNode = (struct tNode *)malloc(sizeof(struct tNode)); tNode-\u003edata = data; tNode-\u003eleft = NULL; tNode-\u003eright = NULL; return(tNode); } int main() { struct tNode *root = newNode(1); root-\u003eleft = newNode(2); root-\u003eright = newNode(3); root-\u003eleft-\u003eleft = newNode(4); root-\u003eleft-\u003eright = newNode(5); inOrder(root); getchar(); return 0; } ","date":"2021-12-21","objectID":"/posts/coding/%E6%97%A0%E9%80%92%E5%BD%92%E4%B8%AD%E5%BA%8F%E6%A0%91%E6%A0%88%E9%81%8D%E5%8E%86/:0:0","tags":["C"],"title":"无递归中序树栈遍历","uri":"/posts/coding/%E6%97%A0%E9%80%92%E5%BD%92%E4%B8%AD%E5%BA%8F%E6%A0%91%E6%A0%88%E9%81%8D%E5%8E%86/"},{"categories":["C"],"content":"双链表 #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e //双链表 typedef struct List { struct List *pnext; struct List *ptail; int date; }List; List *CreateList(int n) { List *head = (List *)malloc(sizeof(List)); //链表头节点 head-\u003edate = 0; head-\u003epnext = NULL; head-\u003eptail = NULL; List *temp = head; for(int i = 1; i \u003c n ; i++) { List *node = (List *)malloc(sizeof(List)); node-\u003edate = i; node-\u003eptail = NULL; node-\u003epnext = NULL; //节点初始化 temp-\u003epnext = node; node-\u003eptail = temp; temp = node; } return head; } void PrintList(List *head) { List *temp = head; while(temp) { printf(\"%d \",temp-\u003edate); temp = temp-\u003epnext; } printf(\"\\n\"); } int LenthList(List *head) { List *temp = head; int i = 0; while(temp) { i++; temp = temp-\u003epnext; } return i; } List *DeleteList(List *head , int n) { //单链删除两个中间变量，双链删除一个中间变量 List *temp = head; if(n \u003e LenthList(head)) { return head; } if(n == 1) { temp = temp-\u003epnext; temp-\u003eptail = NULL; head-\u003epnext = NULL; free(head); return temp; } if(n == LenthList(head)) { for(int i = 1;i \u003c n-1 ;i++) { temp = temp-\u003epnext; } List *temp1 = temp-\u003epnext; temp1-\u003eptail = NULL; temp-\u003epnext = NULL; free(temp1); return head; } if(n \u003e 1 \u0026\u0026 n \u003c LenthList(head)) { for(int i = 1; i \u003c n ; i++) { temp = temp-\u003epnext; } temp-\u003eptail-\u003epnext = temp-\u003epnext; temp-\u003epnext-\u003eptail = temp-\u003eptail; free(temp); return head; } } int main() { List *head = CreateList(5); PrintList(head); printf(\"\\n\"); printf(\"%d\",LenthList(head)); printf(\"\\n\"); printf(\"\\n\"); List *head1 = DeleteList(head,2); PrintList(head1); printf(\"\\n\"); return 0; } ","date":"2021-10-25","objectID":"/posts/coding/%E5%8F%8C%E9%93%BE%E8%A1%A8/:0:1","tags":["C"],"title":"双链表","uri":"/posts/coding/%E5%8F%8C%E9%93%BE%E8%A1%A8/"},{"categories":["C"],"content":"二分查找 二分查找的基本思想是将n个元素分成大致相等的两部分，取a[n/2]与x做比较，如果x=a[n/2],则找到x,算法中止；如果x\u003ca[n/2],则只要在数组a的左半部分继续搜索x,如果x\u003ea[n/2],则只要在数组a的右半部搜索x. 时间复杂度即是while循环的次数或者递归的次数。（这里采用的是递归的方法） int binaryS(int low,int hight,int *a,int key) { if(low\u003ehight) { return -1; } int mid=(low+hight)/2; if(a[mid]==key) { return mid; } else if(a[mid]\u003ckey) { return binaryS(mid+1,hight,a,key); } else { return binaryS(low,mid-1,a,key); } } int search(int* nums, int numsSize, int target){ return binaryS(0, numsSize-1, nums, target); } ","date":"2021-09-21","objectID":"/posts/coding/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/:0:1","tags":["C"],"title":"二分查找","uri":"/posts/coding/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"categories":["C"],"content":"#include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003climits.h\u003e //创建一个栈 struct Stack{ int top; unsigned capacity; int *array; }; //创建一个栈 struct Stack *CreateStack(unsigned capacity) { struct Stack* stack = (struct Stack *)malloc(sizeof(struct Stack)); stack-\u003ecapacity = capacity; stack-\u003etop = -1; stack-\u003earray = (int *)malloc(stack-\u003ecapacity * sizeof(int)); return stack; } int isFull(struct Stack *stack) { return stack-\u003ecapacity - 1 == stack-\u003etop; } int isEmpty(struct Stack *stack) { return stack-\u003etop == -1; } void push(struct Stack* stack, int item) { if (isFull(stack)) return; stack-\u003earray[++stack-\u003etop] = item; printf(\"%d pushed to stack\\n\", item); } int pop(struct Stack* stack) { if (isEmpty(stack)) return INT_MIN; return stack-\u003earray[stack-\u003etop--]; } int peek(struct Stack* stack) { if (isEmpty(stack)) return INT_MIN; return stack-\u003earray[stack-\u003etop]; } int main() { struct Stack* stack = CreateStack(100); push(stack, 10); push(stack, 20); push(stack, 30); printf(\"%d popped from stack\\n\", pop(stack)); return 0; } ","date":"2021-09-12","objectID":"/posts/coding/%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E6%A0%88/:0:0","tags":["C"],"title":"数组实现栈","uri":"/posts/coding/%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E6%A0%88/"},{"categories":["C"],"content":"#include \u003climits.h\u003e #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e // 表示队列 struct Queue{ int front,rear,size; unsigned capacity; int *array; }; //创建一个队列 struct Queue *CreateQueue(unsigned capacity) { struct Queue *queue = (struct Queue *)malloc(sizeof(struct Queue)); queue-\u003ecapacity = capacity; queue-\u003efront = queue-\u003esize = 0; //初始化一个队列节点 queue-\u003erear = capacity - 1; queue-\u003earray = (int *)malloc(queue-\u003ecapacity *sizeof(int)); return queue; } // 判断队列是否满了 int isFull(struct Queue *queue) { return (queue-\u003esize == queue-\u003ecapacity); } // 判断队列是否为空 int isEmpty(struct Queue *queue) { return (queue-\u003esize == 0); } // 1、排队的步骤 // 检查队列是否已满 // 如果已满，则打印溢出并退出 // 如果队列未满，则递增尾部并添加元素 // 2、取消排队的步骤 // 检查队列是否为空 // 如果为空，则打印下溢并退出 // 如果不是空，则在头部和增量头部打印元素 void enqueue(struct Queue *queue , int item) { if(isFull(queue)) return; queue-\u003erear = (queue-\u003erear + 1);// queue-\u003earray[queue-\u003erear] = item; queue-\u003esize = queue-\u003esize + 1; printf(\"%d enqueued to queue\\n\", item); } int dequeue(struct Queue* queue) { if (isEmpty(queue)) return INT_MIN; int item = queue-\u003earray[queue-\u003efront]; queue-\u003efront = (queue-\u003efront + 1) % queue-\u003ecapacity; queue-\u003esize = queue-\u003esize - 1; return item; } // 获取当前队列的front int front(struct Queue* queue) { if (isEmpty(queue)) return INT_MIN; return queue-\u003earray[queue-\u003efront]; } // 获取当前队列的rear int rear(struct Queue* queue) { if (isEmpty(queue)) return INT_MIN; return queue-\u003earray[queue-\u003erear]; } int main() { struct Queue* queue = CreateQueue(1000); //创建队列 enqueue(queue, 10); //排队 enqueue(queue, 20); enqueue(queue, 30); enqueue(queue, 40); printf(\"%d dequeued from queue\\n\\n\", dequeue(queue)); printf(\"Front item is %d\\n\", front(queue)); printf(\"Rear item is %d\\n\", rear(queue)); return 0; } ","date":"2021-08-13","objectID":"/posts/coding/%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/:0:0","tags":["C"],"title":"数组实现队列","uri":"/posts/coding/%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"},{"categories":["C"],"content":"#include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e //队列节点 struct Qnode { int key; struct Qnode *next; }; struct Queue{ struct Qnode *rear , *front; }; //创建新队列节点 struct Qnode *newnode(int k) { struct Qnode *temp = (struct Qnode *)malloc(sizeof(struct Qnode)); temp-\u003ekey = k; temp-\u003enext = NULL; return temp; } //利用链表创建新队列 struct Queue *CreateQueue() { struct Queue *q = (struct Queue *)malloc(sizeof(struct Queue)); q-\u003efront = q-\u003erear = NULL; return q; } //排队 void enqueue(struct Queue *q , int k) { struct Qnode *temp = newnode(k); if(q-\u003erear == NULL) { q-\u003erear = q-\u003efront = temp; return; } q-\u003erear-\u003enext = temp; q-\u003erear = temp; } //取消排队 void dequeue(struct Queue* q) { if (q-\u003efront == NULL) return; struct Qnode* temp = q-\u003efront; q-\u003efront = q-\u003efront-\u003enext; if (q-\u003efront == NULL) q-\u003erear = NULL; free(temp); } int main() { struct Queue* q = CreateQueue(); enqueue(q, 10); enqueue(q, 20); dequeue(q); dequeue(q); enqueue(q, 30); enqueue(q, 40); enqueue(q, 50); dequeue(q); printf(\"Queue Front : %d \\n\", q-\u003efront-\u003ekey); printf(\"Queue Rear : %d\", q-\u003erear-\u003ekey); return 0; } ","date":"2021-08-12","objectID":"/posts/coding/%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/:0:0","tags":["C"],"title":"链表实现队列","uri":"/posts/coding/%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"},{"categories":["C"],"content":"#include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cmath.h\u003e #include \u003cunistd.h\u003e typedef struct Date { int numb; char *name; }Date; typedef struct Node { int date; struct Node *point; }Node; int LenthList(Node *head) { int i; Node *temp = head; while(temp) { temp = temp-\u003epoint; i++; } return i; } void PrintList(Node *head) { Node *temp = head; while(temp) { printf(\"%d \",temp-\u003edate); temp = temp-\u003epoint; } printf(\"\\n\"); } Node *CraeteList(int n) { Node *head = (Node *)malloc(sizeof(Node)); head-\u003epoint = NULL; head-\u003edate = 0; Node *temp = head; for(int i = 1;i \u003c n;i++) { Node *node = (Node *)malloc(sizeof(Node)); node-\u003epoint = NULL; node-\u003edate = i; temp-\u003epoint = node; temp = node; } return head; } Node *InsertList(Node *head , int n ,int numb) { if(n \u003e LenthList(head)+1 || n \u003c 1) { return head; } Node *temp = (Node *)malloc(sizeof(Node)); temp-\u003epoint = NULL; temp-\u003edate = numb; if(n == 1) { Node *nhead = (Node *)malloc(sizeof(Node)); nhead-\u003epoint = head; temp-\u003epoint = head; nhead-\u003epoint = temp; head = nhead; free(nhead); return head; } if(n \u003e 1 \u0026\u0026 n \u003c= LenthList(head)) { Node *temp1 = head; while (temp1-\u003epoint != NULL \u0026\u0026 n \u003e 2) { temp1 = temp1-\u003epoint; n--; } temp-\u003epoint = temp1-\u003epoint; temp1-\u003epoint = temp; return head; } if (n == LenthList(head)+1) { Node *temp2 = head; while (temp2!=NULL) { if (temp2-\u003epoint = NULL) { break; } temp2 = temp2-\u003epoint; } temp = temp2-\u003epoint; return head; } return head; } Node *CopyList(Node *head) { Node *nhead = (Node *)malloc(sizeof(Node)); nhead-\u003epoint = NULL; nhead-\u003edate = head-\u003edate; Node *temp = head; Node *ntemp = nhead; while (temp-\u003epoint != NULL) { Node *node = (Node *)malloc(sizeof(Node)); node-\u003epoint = NULL; ntemp-\u003epoint = node; ntemp = node; temp = temp-\u003epoint; ntemp-\u003edate = temp-\u003edate; } return nhead; } Node *DeleteList(Node *head , int n) { if(n \u003c= 0 || n \u003e LenthList(head)) { return head; } if(n == 1) { Node *temp = head; temp = temp-\u003epoint; head = temp; return head; } if(n == LenthList(head)) { Node *temp = head; for(int i = 1 ; i \u003c n+1 ; i++) { temp = temp-\u003epoint; } temp-\u003epoint = NULL; return head; } } int main() { Node *head = CraeteList(5); PrintList(head); Node *head2 = CopyList(head); PrintList(head2); printf(\"LenthList = %d\",LenthList(head)); Node *head3 = DeleteList(head,5); PrintList(head3); Node *head1 = InsertList(head,5,10); PrintList(head1); return 0; } ","date":"2021-07-21","objectID":"/posts/thinking/c_list/:0:0","tags":["C"],"title":"C_List","uri":"/posts/thinking/c_list/"}]