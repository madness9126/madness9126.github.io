<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>C - Tag - アニャ様です！</title>
        <link>/tags/c/</link>
        <description>C - Tag - アニャ様です！</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>1091451551@qq.com (アニャ様)</managingEditor>
            <webMaster>1091451551@qq.com (アニャ様)</webMaster><lastBuildDate>Wed, 21 Sep 2022 19:51:35 &#43;0800</lastBuildDate><atom:link href="/tags/c/" rel="self" type="application/rss+xml" /><item>
    <title>Avl树</title>
    <link>/posts/coding/avl%E6%A0%91/</link>
    <pubDate>Wed, 21 Sep 2022 19:51:35 &#43;0800</pubDate>
    <author>Author</author>
    <guid>/posts/coding/avl%E6%A0%91/</guid>
    <description><![CDATA[Avl树 AVL树本质上还是一棵二叉搜索树，它的特点是： 本身首先是一棵二叉搜索树。 带有平衡条件：每个结点的左右子树的高度之差的绝对值（平衡因子]]></description>
</item>
<item>
    <title>二分查找</title>
    <link>/posts/coding/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</link>
    <pubDate>Wed, 21 Sep 2022 12:13:26 &#43;0800</pubDate>
    <author>Author</author>
    <guid>/posts/coding/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</guid>
    <description><![CDATA[二分查找 二分查找的基本思想是将n个元素分成大致相等的两部分，取a[n/2]与x做比较，如果x=a[n/2],则找到x,算法中止；如果x&lt]]></description>
</item>
<item>
    <title>C_List</title>
    <link>/posts/thinking/c_list/</link>
    <pubDate>Wed, 21 Sep 2022 00:09:12 &#43;0800</pubDate>
    <author>Author</author>
    <guid>/posts/thinking/c_list/</guid>
    <description><![CDATA[#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;math.h&gt; #include &lt;unistd.h&gt; typedef struct Date { int numb; char *name; }Date; typedef struct Node { int date; struct Node *point; }Node; int LenthList(Node *head) { int i; Node *temp = head; while(temp) { temp = temp-&gt;point; i++; } return i; } void PrintList(Node *head) { Node *temp = head; while(temp) { printf(&#34;%d &#34;,temp-&gt;date); temp = temp-&gt;point; } printf(&#34;\n&#34;); } Node *CraeteList(int n) { Node *head = (Node *)malloc(sizeof(Node)); head-&gt;point = NULL; head-&gt;date = 0; Node *temp = head; for(int i = 1;i &lt; n;i++) { Node *node = (Node *)malloc(sizeof(Node)); node-&gt;point = NULL; node-&gt;date = i; temp-&gt;point = node; temp = node; } return head; } Node *InsertList(Node *head , int n ,int numb) { if(n &gt; LenthList(head)+1 || n &lt; 1) { return head; } Node *temp = (Node *)malloc(sizeof(Node)); temp-&gt;point = NULL; temp-&gt;date = numb; if(n == 1) { Node *nhead = (Node *)malloc(sizeof(Node)); nhead-&gt;point = head; temp-&gt;point = head; nhead-&gt;point = temp; head = nhead; free(nhead); return head; } if(n &gt; 1 &amp;&amp; n &lt;= LenthList(head)) { Node *temp1 = head; while (temp1-&gt;point !]]></description>
</item>
<item>
    <title>文件管理</title>
    <link>/posts/thinking/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/</link>
    <pubDate>Sun, 24 Jul 2022 20:57:29 &#43;0800</pubDate>
    <author>アニャ様</author>
    <guid>/posts/thinking/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/</guid>
    <description><![CDATA[C语言的文件管理部分内容 1. 从文件中逐个输入字符及向文件中逐个输出字符的顺序读写函数 fgetc 和 fputc 调整文件读写位置到文件开始处的函数 rewind 头文件：#inc]]></description>
</item>
</channel>
</rss>
