<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>C - Category - アニャ様です！</title>
        <link>/categories/c/</link>
        <description>C - Category - アニャ様です！</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>1091451551@qq.com (アニャ様)</managingEditor>
            <webMaster>1091451551@qq.com (アニャ様)</webMaster><lastBuildDate>Wed, 21 Sep 2022 20:44:20 &#43;0800</lastBuildDate><atom:link href="/categories/c/" rel="self" type="application/rss+xml" /><item>
    <title>无递归中序树栈遍历</title>
    <link>/posts/coding/%E6%97%A0%E9%80%92%E5%BD%92%E4%B8%AD%E5%BA%8F%E6%A0%91%E6%A0%88%E9%81%8D%E5%8E%86/</link>
    <pubDate>Wed, 21 Sep 2022 20:44:20 &#43;0800</pubDate>
    <author>Author</author>
    <guid>/posts/coding/%E6%97%A0%E9%80%92%E5%BD%92%E4%B8%AD%E5%BA%8F%E6%A0%91%E6%A0%88%E9%81%8D%E5%8E%86/</guid>
    <description><![CDATA[#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #define bool int //树节点 struct tNode { int data; struct tNode *left; struct tNode *right; }; //堆栈 struct sNode { struct tNode *t; struct sNode *next; }; //堆栈相关函数 void push(struct sNode **top_ref , struct tNode *t); struct tNode *pop(struct sNode **top_ref); bool isEmpty(struct sNode *top); //迭代遍历顺]]></description>
</item>
<item>
    <title>二叉树</title>
    <link>/posts/coding/%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
    <pubDate>Wed, 21 Sep 2022 20:42:40 &#43;0800</pubDate>
    <author>Author</author>
    <guid>/posts/coding/%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
    <description><![CDATA[binary tree 二叉树 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; //树节点 struct node { int data; struct node *left; struct node *right; }; struct node *newnode(int data) { struct node *node = (struct node *)malloc(sizeof(struct node)); node-&gt;data = data; node-&gt;left = NULL; node-&gt;right = NULL; return (node); } //树的遍历 //前序、中序、后序 void printPostorder(struct node]]></description>
</item>
<item>
    <title>链表实现队列</title>
    <link>/posts/coding/%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</link>
    <pubDate>Wed, 21 Sep 2022 20:41:40 &#43;0800</pubDate>
    <author>Author</author>
    <guid>/posts/coding/%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</guid>
    <description><![CDATA[#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; //队列节点 struct Qnode { int key; struct Qnode *next; }; struct Queue{ struct Qnode *rear , *front; }; //创建新队列节点 struct Qnode *newnode(int k) { struct Qnode *temp = (struct Qnode *)malloc(sizeof(struct Qnode)); temp-&gt;key = k; temp-&gt;next = NULL; return temp; } //利用链表创建新队列 struct]]></description>
</item>
<item>
    <title>数组实现队列</title>
    <link>/posts/coding/%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</link>
    <pubDate>Wed, 21 Sep 2022 20:40:48 &#43;0800</pubDate>
    <author>Author</author>
    <guid>/posts/coding/%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</guid>
    <description><![CDATA[#include &lt;limits.h&gt; #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; // 表示队列 struct Queue{ int front,rear,size; unsigned capacity; int *array; }; //创建一个队列 struct Queue *CreateQueue(unsigned capacity) { struct Queue *queue = (struct Queue *)malloc(sizeof(struct Queue)); queue-&gt;capacity = capacity; queue-&gt;front = queue-&gt;size = 0; //初始化一个队列节点 queue-&gt;rear = capacity - 1; queue-&gt;array = (int *)malloc(queue-&gt;capacity *sizeof(int));]]></description>
</item>
<item>
    <title>数组实现栈</title>
    <link>/posts/coding/%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E6%A0%88/</link>
    <pubDate>Wed, 21 Sep 2022 20:40:03 &#43;0800</pubDate>
    <author>Author</author>
    <guid>/posts/coding/%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E6%A0%88/</guid>
    <description><![CDATA[#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;limits.h&gt; //创建一个栈 struct Stack{ int top; unsigned capacity; int *array; }; //创建一个栈 struct Stack *CreateStack(unsigned capacity) { struct Stack* stack = (struct Stack *)malloc(sizeof(struct Stack)); stack-&gt;capacity = capacity; stack-&gt;top = -1; stack-&gt;array = (int *)malloc(stack-&gt;capacity * sizeof(int)); return stack; } int isFull(struct Stack *stack) { return stack-&gt;capacity - 1 == stack-&gt;top; } int]]></description>
</item>
<item>
    <title>字符串匹配算法</title>
    <link>/posts/coding/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95/</link>
    <pubDate>Wed, 21 Sep 2022 20:35:40 &#43;0800</pubDate>
    <author>Author</author>
    <guid>/posts/coding/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95/</guid>
    <description><![CDATA[#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; //字符串匹配搜索算法BF、RK、BM、KMP /* * BF算法，暴力匹配算法（） * Rk算法，利用哈希函数将字符串转换成数字，比较哈希值，]]></description>
</item>
<item>
    <title>双链表</title>
    <link>/posts/coding/%E5%8F%8C%E9%93%BE%E8%A1%A8/</link>
    <pubDate>Wed, 21 Sep 2022 20:33:33 &#43;0800</pubDate>
    <author>Author</author>
    <guid>/posts/coding/%E5%8F%8C%E9%93%BE%E8%A1%A8/</guid>
    <description><![CDATA[双链表 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; //双链表 typedef struct List { struct List *pnext; struct List *ptail; int date; }List; List *CreateList(int n) { List *head = (List *)malloc(sizeof(List)); //链表头节点 head-&gt;date = 0; head-&gt;pnext = NULL; head-&gt;ptail = NULL; List *temp = head; for(int i = 1; i &lt; n ; i++) { List *node = (List *)malloc(sizeof(List)); node-&gt;date]]></description>
</item>
<item>
    <title>Avl树</title>
    <link>/posts/coding/avl%E6%A0%91/</link>
    <pubDate>Wed, 21 Sep 2022 19:51:35 &#43;0800</pubDate>
    <author>Author</author>
    <guid>/posts/coding/avl%E6%A0%91/</guid>
    <description><![CDATA[Avl树 AVL树本质上还是一棵二叉搜索树，它的特点是： 本身首先是一棵二叉搜索树。 带有平衡条件：每个结点的左右子树的高度之差的绝对值（平衡因子]]></description>
</item>
<item>
    <title>二分查找</title>
    <link>/posts/coding/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</link>
    <pubDate>Wed, 21 Sep 2022 12:13:26 &#43;0800</pubDate>
    <author>Author</author>
    <guid>/posts/coding/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</guid>
    <description><![CDATA[二分查找 二分查找的基本思想是将n个元素分成大致相等的两部分，取a[n/2]与x做比较，如果x=a[n/2],则找到x,算法中止；如果x&lt]]></description>
</item>
<item>
    <title>C_List</title>
    <link>/posts/thinking/c_list/</link>
    <pubDate>Wed, 21 Sep 2022 00:09:12 &#43;0800</pubDate>
    <author>Author</author>
    <guid>/posts/thinking/c_list/</guid>
    <description><![CDATA[#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;math.h&gt; #include &lt;unistd.h&gt; typedef struct Date { int numb; char *name; }Date; typedef struct Node { int date; struct Node *point; }Node; int LenthList(Node *head) { int i; Node *temp = head; while(temp) { temp = temp-&gt;point; i++; } return i; } void PrintList(Node *head) { Node *temp = head; while(temp) { printf(&#34;%d &#34;,temp-&gt;date); temp = temp-&gt;point; } printf(&#34;\n&#34;); } Node *CraeteList(int n) { Node *head = (Node *)malloc(sizeof(Node)); head-&gt;point = NULL; head-&gt;date = 0; Node *temp = head; for(int i = 1;i &lt; n;i++) { Node *node = (Node *)malloc(sizeof(Node)); node-&gt;point = NULL; node-&gt;date = i; temp-&gt;point = node; temp = node; } return head; } Node *InsertList(Node *head , int n ,int numb) { if(n &gt; LenthList(head)+1 || n &lt; 1) { return head; } Node *temp = (Node *)malloc(sizeof(Node)); temp-&gt;point = NULL; temp-&gt;date = numb; if(n == 1) { Node *nhead = (Node *)malloc(sizeof(Node)); nhead-&gt;point = head; temp-&gt;point = head; nhead-&gt;point = temp; head = nhead; free(nhead); return head; } if(n &gt; 1 &amp;&amp; n &lt;= LenthList(head)) { Node *temp1 = head; while (temp1-&gt;point !]]></description>
</item>
</channel>
</rss>
